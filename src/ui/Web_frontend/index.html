HTML_CONTENT = '''
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de P√¢ncreas Artificial</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .warning {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        .chart-container {
            height: 400px;
            position: relative;
        }

        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .status-item {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .status-item.critical {
            background: linear-gradient(135deg, #ff6b6b, #e17055);
        }

        .status-item.warning {
            background: linear-gradient(135deg, #fdcb6e, #e17055);
        }

        .status-item.good {
            background: linear-gradient(135deg, #55a3ff, #00b894);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: translateY(0);
        }

        button.danger {
            background: linear-gradient(135deg, #ff6b6b, #e17055);
        }

        button.success {
            background: linear-gradient(135deg, #55a3ff, #00b894);
        }

        .meal-section {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }

        input, select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            transition: border-color 0.3s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #74b9ff;
            box-shadow: 0 0 10px rgba(116, 185, 255, 0.3);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .metric-card {
            background: linear-gradient(135deg, #a8e6cf, #7fcdcd);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            color: #2d3436;
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            z-index: 1000;
        }

        .connected {
            background: #00b894;
        }

        .disconnected {
            background: #e17055;
            animation: pulse 1s infinite;
        }

        .log-container {
            background: #2d3436;
            color: #74b9ff;
            padding: 15px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 5px;
            border-left: 3px solid #74b9ff;
            padding-left: 10px;
        }

        .log-entry.error {
            border-left-color: #ff6b6b;
            color: #ff6b6b;
        }

        .log-entry.warning {
            border-left-color: #fdcb6e;
            color: #fdcb6e;
        }

        .log-entry.info {
            border-left-color: #55a3ff;
            color: #55a3ff;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            .status-grid {
                grid-template-columns: 1fr;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="connectionStatus" class="connection-status disconnected">
        Desconectado
    </div>

    <div class="container">
        <div class="header">
            <h1>ü©∫ Sistema de P√¢ncreas Artificial</h1>
            <div class="warning">
                ‚ö†Ô∏è SISTEMA EXPERIMENTAL - APENAS PARA SIMULA√á√ÉO E PESQUISA
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>üìä Glicemia em Tempo Real</h2>
                <div class="chart-container">
                    <canvas id="glucoseChart"></canvas>
                </div>
            </div>

            <div class="card">
                <h2>üîç Status do Sistema</h2>
                <div class="status-grid">
                    <div class="status-item" id="glucoseStatus">
                        <div class="metric-value" id="currentGlucose">--</div>
                        <div class="metric-label">Glicemia Atual (mg/dL)</div>
                    </div>
                    <div class="status-item" id="systemStatus">
                        <div class="metric-value" id="systemMode">--</div>
                        <div class="metric-label">Modo do Sistema</div>
                    </div>
                    <div class="status-item" id="confidenceStatus">
                        <div class="metric-value" id="systemConfidence">--</div>
                        <div class="metric-label">Confian√ßa (%)</div>
                    </div>
                    <div class="status-item" id="insulinStatus">
                        <div class="metric-value" id="lastDose">--</div>
                        <div class="metric-label">√öltima Dose (U)</div>
                    </div>
                </div>

                <div class="controls">
                    <button onclick="startSystem()" class="success">‚ñ∂Ô∏è Iniciar</button>
                    <button onclick="pauseSystem()" class="warning">‚è∏Ô∏è Pausar</button>
                    <button onclick="stopSystem()" class="danger">‚èπÔ∏è Parar</button>
                    <button onclick="resetSystem()">üîÑ Reset</button>
                </div>
            </div>
        </div>

        <div class="meal-section">
            <h2>üçΩÔ∏è Simula√ß√£o de Refei√ß√µes</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                <div class="form-group">
                    <label for="carbAmount">Carboidratos (g):</label>
                    <input type="number" id="carbAmount" value="30" min="1" max="150">
                </div>
                <div class="form-group">
                    <label for="absorptionProfile">Perfil de Absor√ß√£o:</label>
                    <select id="absorptionProfile">
                        <option value="fast">R√°pida (a√ß√∫car, frutas)</option>
                        <option value="medium" selected>M√©dia (arroz, p√£o)</option>
                        <option value="slow">Lenta (massas, legumes)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="giIndex">√çndice Glic√™mico:</label>
                    <input type="number" id="giIndex" value="50" min="1" max="100">
                </div>
                <button onclick="addMeal()" class="success">üçΩÔ∏è Adicionar Refei√ß√£o</button>
            </div>
        </div>

        <div class="card">
            <h2>üìà M√©tricas de Desempenho</h2>
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="timeInRange">--</div>
                    <div class="metric-label">Tempo em Faixa (%)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="avgGlucose">--</div>
                    <div class="metric-label">Glicemia M√©dia</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="hypoEvents">--</div>
                    <div class="metric-label">Eventos de Hipoglicemia</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="hyperEvents">--</div>
                    <div class="metric-label">Eventos de Hiperglicemia</div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>üö® Cen√°rios de Teste</h2>
            <div class="controls">
                <button onclick="injectScenario('meal_challenge')">üçï Refei√ß√£o Desafio</button>
                <button onclick="injectScenario('sensor_error')">üì° Erro de Sensor</button>
                <button onclick="injectScenario('exercise')">üèÉ Exerc√≠cio</button>
                <button onclick="exportData('simulation')">üíæ Exportar Dados</button>
            </div>
        </div>

        <div class="card">
            <h2>üìù Log do Sistema</h2>
            <div class="log-container" id="systemLog">
                <div class="log-entry info">Sistema iniciado - aguardando conex√£o...</div>
            </div>
        </div>
    </div>

    <script>
        // Configura√ß√£o WebSocket e Chart.js
        let ws = null;
        let glucoseChart = null;
        let isConnected = false;

        // Dados para o gr√°fico
        let glucoseData = {
            labels: [],
            datasets: [{
                label: 'Glicemia (mg/dL)',
                data: [],
                borderColor: '#74b9ff',
                backgroundColor: 'rgba(116, 185, 255, 0.1)',
                borderWidth: 3,
                fill: true,
                tension: 0.4
            }]
        };

        // Inicializar aplica√ß√£o
        window.onload = function() {
            initializeChart();
            connectWebSocket();
            loadInitialData();
        };

        function initializeChart() {
            const ctx = document.getElementById('glucoseChart').getContext('2d');
            
            glucoseChart = new Chart(ctx, {
                type: 'line',
                data: glucoseData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'HH:mm'
                                }
                            },
                            title: {
                                display: true,
                                text: 'Tempo'
                            }
                        },
                        y: {
                            min: 50,
                            max: 300,
                            title: {
                                display: true,
                                text: 'Glicemia (mg/dL)'
                            },
                            plugins: [{
                                beforeDatasetsDraw: function(chart) {
                                    const ctx = chart.ctx;
                                    const yAxis = chart.scales.y;
                                    
                                    // Zona alvo (70-180 mg/dL)
                                    const topY = yAxis.getPixelForValue(180);
                                    const bottomY = yAxis.getPixelForValue(70);
                                    
                                    ctx.save();
                                    ctx.fillStyle = 'rgba(0, 184, 148, 0.1)';
                                    ctx.fillRect(chart.chartArea.left, topY, chart.chartArea.right - chart.chartArea.left, bottomY - topY);
                                    ctx.restore();
                                }
                            }]
                        }
                    }
                }
            });
        }

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = function() {
                isConnected = true;
                updateConnectionStatus(true);
                addLogEntry('Conectado ao sistema APS', 'info');
                
                // Enviar ping peri√≥dico
                setInterval(() => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({type: 'ping'}));
                    }
                }, 30000);
            };
            
            ws.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleWebSocketMessage(data);
                } catch (e) {
                    console.error('Erro ao processar mensagem WebSocket:', e);
                }
            };
            
            ws.onclose = function() {
                isConnected = false;
                updateConnectionStatus(false);
                addLogEntry('Conex√£o perdida - tentando reconectar...', 'warning');
                
                // Tentar reconectar ap√≥s 5 segundos
                setTimeout(connectWebSocket, 5000);
            };
            
            ws.onerror = function(error) {
                addLogEntry('Erro de conex√£o WebSocket', 'error');
            };
        }

        function handleWebSocketMessage(data) {
            if (data.type === 'real_time_update') {
                updateGlucoseChart(data.glucose_history);
                updateSystemStatus(data.system_status, data.current_glucose);
                updateMetrics(data.metrics);
            } else if (data.type === 'pong') {
                // Resposta do ping - conex√£o ok
            }
        }

        function updateGlucoseChart(glucoseHistory) {
            if (!glucoseHistory || glucoseHistory.length === 0) return;
            
            // Atualizar dados do gr√°fico
            glucoseData.labels = glucoseHistory.map(point => new Date(point.timestamp));
            glucoseData.datasets[0].data = glucoseHistory.map(point => point.value);
            
            glucoseChart.update('none');
        }

        function updateSystemStatus(systemStatus, currentGlucose) {
            // Atualizar glicemia atual
            document.getElementById('currentGlucose').textContent = 
                currentGlucose ? currentGlucose.toFixed(1) : '--';
            
            // Atualizar cor baseada na glicemia
            const glucoseStatus = document.getElementById('glucoseStatus');
            if (currentGlucose) {
                if (currentGlucose < 70) {
                    glucoseStatus.className = 'status-item critical';
                } else if (currentGlucose < 80 || currentGlucose > 180) {
                    glucoseStatus.className = 'status-item warning';
                } else {
                    glucoseStatus.className = 'status-item good';
                }
            }
            
            // Atualizar modo do sistema
            document.getElementById('systemMode').textContent = 
                systemStatus.mode || '--';
            
            // Atualizar confian√ßa
            const confidence = systemStatus.confidence * 100;
            document.getElementById('systemConfidence').textContent = 
                confidence ? confidence.toFixed(0) + '%' : '--';
            
            // Cor da confian√ßa
            const confidenceStatus = document.getElementById('confidenceStatus');
            if (confidence > 80) {
                confidenceStatus.className = 'status-item good';
            } else if (confidence > 60) {
                confidenceStatus.className = 'status-item warning';
            } else {
                confidenceStatus.className = 'status-item critical';
            }
        }

        function updateMetrics(metrics) {
            if (!metrics) return;
            
            document.getElementById('timeInRange').textContent = 
                metrics.time_in_range ? (metrics.time_in_range * 100).toFixed(1) + '%' : '--';
            
            document.getElementById('avgGlucose').textContent = 
                metrics.avg_glucose ? metrics.avg_glucose.toFixed(1) : '--';
            
            document.getElementById('hypoEvents').textContent = 
                metrics.hypoglycemia_events || '0';
            
            document.getElementById('hyperEvents').textContent = 
                metrics.hyperglycemia_events || '0';
        }

        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connectionStatus');
            statusElement.textContent = connected ? 'Conectado' : 'Desconectado';
            statusElement.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
        }

        function addLogEntry(message, type = 'info') {
            const logContainer = document.getElementById('systemLog');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            // Manter apenas √∫ltimas 50 entradas
            while (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }

        async function loadInitialData() {
            try {
                // Carregar dados iniciais
                const response = await fetch('/api/glucose?hours=6');
                const data = await response.json();
                
                if (data.glucose_history) {
                    updateGlucoseChart(data.glucose_history);
                }
                
                // Carregar status
                const statusResponse = await fetch('/api/status');
                const statusData = await statusResponse.json();
                
                updateSystemStatus({
                    mode: statusData.current_mode,
                    confidence: statusData.system_confidence,
                    running: statusData.is_running
                }, statusData.current_glucose);
                
            } catch (error) {
                addLogEntry('Erro ao carregar dados iniciais', 'error');
            }
        }

        // Fun√ß√µes de controle
        async function startSystem() {
            try {
                const response = await fetch('/api/control', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        action: 'start',
                        parameters: {
                            duration_hours: 24,
                            acceleration: 1
                        }
                    })
                });
                
                const result = await response.json();
                addLogEntry(result.message, 'info');
                
            } catch (error) {
                addLogEntry('Erro ao iniciar sistema', 'error');
            }
        }

        async function pauseSystem() {
            addLogEntry('Fun√ß√£o pausar ainda n√£o implementada', 'warning');
        }

        async function stopSystem() {
            try {
                const response = await fetch('/api/control', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({action: 'stop'})
                });
                
                const result = await response.json();
                addLogEntry(result.message, 'info');
                
            } catch (error) {
                addLogEntry('Erro ao parar sistema', 'error');
            }
        }

        async function resetSystem() {
            try {
                const response = await fetch('/api/control', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({action: 'reset'})
                });
                
                const result = await response.json();
                addLogEntry(result.message, 'info');
                
                // Limpar gr√°fico
                glucoseData.labels = [];
                glucoseData.datasets[0].data = [];
                glucoseChart.update();
                
            } catch (error) {
                addLogEntry('Erro ao resetar sistema', 'error');
            }
        }

        async function addMeal() {
            const carbs = document.getElementById('carbAmount').value;
            const profile = document.getElementById('absorptionProfile').value;
            const giIndex = document.getElementById('giIndex').value;
            
            try {
                const response = await fetch('/api/meal', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        carbs: parseFloat(carbs),
                        absorption_profile: profile,
                        gi_index: parseFloat(giIndex)
                    })
                });
                
                const result = await response.json();
                addLogEntry(result.message, 'info');
                
            } catch (error) {
                addLogEntry('Erro ao adicionar refei√ß√£o', 'error');
            }
        }

        async function injectScenario(scenarioName) {
            try {
                const response = await fetch(`/api/inject-scenario?scenario_name=${scenarioName}`, {
                    method: 'POST'
                });
                
                const result = await response.json();
                addLogEntry(result.message, 'info');
                
            } catch (error) {
                addLogEntry(`Erro ao injetar cen√°rio ${scenarioName}`, 'error');
            }
        }

        async function exportData(dataType) {
            try {
                const response = await fetch(`/api/export/${dataType}`);
                
                if (response.headers.get('content-type')?.includes('application/json')) {
                    const result = await response.json();
                    // Criar download do JSON
                    const blob = new Blob([JSON.stringify(result.data, null, 2)], {
                        type: 'application/json'
                    });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = result.filename;
                    a.click();
                    URL.revokeObjectURL(url);
                } else {
                    // Download direto do arquivo
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `export_${dataType}_${new Date().toISOString().slice(0,10)}.csv`;
                    a.click();
                    URL.revokeObjectURL(url);
                }
                
                addLogEntry(`Dados ${dataType} exportados com sucesso`, 'info');
                
            } catch (error) {
                addLogEntry(`Erro ao exportar dados ${dataType}`, 'error');
            }
        }

        // Atualizar m√©tricas periodicamente
        setInterval(async () => {
            try {
                const response = await fetch('/api/metrics?hours=24');
                const data = await response.json();
                updateMetrics(data.system_metrics);
            } catch (error) {
                // Silenciosamente ignorar erros de m√©tricas
            }
        }, 60000); // A cada minuto
    </script>
</body>
</html>
'''

# Salvar arquivo HTML
def save_html_file():
    """Salva o arquivo HTML da interface web"""
    import os
    os.makedirs('src/ui/web_frontend', exist_ok=True)
    
    with open('src/ui/web_frontend/index.html', 'w', encoding='utf-8') as f:
        f.write(HTML_CONTENT)
    
    print("Interface web salva em src/ui/web_frontend/index.html")

if __name__ == "__main__":
    save_html_file()# api/rest.py - API REST para Sistema APS
"""
API REST para Sistema de P√¢ncreas Artificial

Endpoints:
- GET /status - Status do sistema
- POST /meal - Adicionar refei√ß√£o 
- GET /glucose - Hist√≥rico de glicemia
- GET /metrics - M√©tricas de desempenho
- POST /control/start - Iniciar sistema
- POST /control/stop - Parar sistema
- WebSocket /ws - Dados em tempo real
"""

from fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, FileResponse
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
import asyncio
import json
import logging
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

# Modelos de dados da API
class MealRequest(BaseModel):
    carbs: float
    absorption_profile: str = "medium"  # fast, medium, slow
    gi_index: float = 50.0

class SystemStatus(BaseModel):
    is_running: bool
    current_mode: str
    current_glucose: Optional[float]
    system_confidence: float
    last_dose: Optional[float]
    emergency_mode: bool

class GlucoseReading(BaseModel):
    timestamp: datetime
    value: float
    true_value: Optional[float] = None

class ControlCommand(BaseModel):
    action: str  # start, stop, pause, reset
    parameters: Optional[Dict[str, Any]] = {}

def create_app(aps_system) -> FastAPI:
    """
    Cria aplica√ß√£o FastAPI para o sistema APS
    
    Args:
        aps_system: Inst√¢ncia do sistema APS
        
    Returns:
        Aplica√ß√£o FastAPI configurada
    """
    
    app = FastAPI(
        title="Sistema de P√¢ncreas Artificial",
        description="API para controle e monitoramento do APS",
        version="1.0.0",
        docs_url="/docs",
        redoc_url="/redoc"
    )
    
    # Gerenciador de conex√µes WebSocket
    class ConnectionManager:
        def __init__(self):
            self.active_connections: List[WebSocket] = []
        
        async def connect(self, websocket: WebSocket):
            await websocket.accept()
            self.active_connections.append(websocket)
            logger.info(f"WebSocket conectado. Total: {len(self.active_connections)}")
        
        def disconnect(self, websocket: WebSocket):
            self.active_connections.remove(websocket)
            logger.info(f"WebSocket desconectado. Total: {len(self.active_connections)}")
        
        async def broadcast(self, data: dict):
            disconnected = []
            for connection in self.active_connections:
                try:
                    await connection.send_text(json.dumps(data, default=str))
                except Exception as e:
                    logger.error(f"Erro ao enviar WebSocket: {e}")
                    disconnected.append(connection)
            
            # Remover conex√µes mortas
            for conn in disconnected:
                if conn in self.active_connections:
                    self.active_connections.remove(conn)
    
    manager = ConnectionManager()
    
    # Task para broadcast peri√≥dico
    async def periodic_broadcast():
        while True:
            try:
                if aps_system.running and manager.active_connections:
                    # Coletar dados atuais
                    current_glucose = aps_system.simulator.get_current_glucose()
                    glucose_history = aps_system.simulator.get_glucose_history(hours=6)
                    metrics = await aps_system.get_metrics(hours=1)
                    
                    broadcast_data = {
                        "type": "real_time_update",
                        "timestamp": datetime.now().isoformat(),
                        "current_glucose": current_glucose,
                        "glucose_history": glucose_history[-60:],  # √öltimas 10h
                        "metrics": metrics,
                        "system_status": {
                            "running": aps_system.running,
                            "mode": aps_system.controller.current_mode.value,
                            "confidence": aps_system.controller._calculate_system_confidence(),
                            "emergency_mode": aps_system.safety_monitor.emergency_mode
                        }
                    }
                    
                    await manager.broadcast(broadcast_data)
                
                await asyncio.sleep(30)  # Atualizar a cada 30 segundos
                
            except Exception as e:
                logger.error(f"Erro no broadcast peri√≥dico: {e}")
                await asyncio.sleep(60)
    
    # Iniciar task de broadcast
    @app.on_event("startup")
    async def startup_event():
        asyncio.create_task(periodic_broadcast())
    
    # Servir arquivos est√°ticos
    app.mount("/static", StaticFiles(directory="src/ui/static"), name="static")
    
    # Endpoints da API
    
    @app.get("/", response_class=HTMLResponse)
    async def get_home():
        """Interface web principal"""
        return FileResponse("src/ui/web_frontend/index.html")
    
    @app.get("/api/status", response_model=SystemStatus)
    async def get_status():
        """Status atual do sistema"""
        try:
            current_glucose = None